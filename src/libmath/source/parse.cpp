// std headers
#include <cassert>
#include <cstdlib>
#include <ios>
#include <istream>
#include <memory>
#include <stdexcept>
#include <string>

// realpack headers
#include "parse.hpp"
#include "parser.h"

// functions generated by lemon
extern void* RealMathParseAlloc(void* (*mallocProc)(size_t));
extern void RealMathParse(void* yyp,                            /* The parser */
                          int yymajor,                          /* The major token code number */
                          real::math::parse::token* yyminor,    /* The value for the token */
                          real::math::parse::parse_state* state /* Optional %extra_argument parameter */
);
extern void RealMathParseFree(void* p,                /* The parser to be deleted */
                              void (*freeProc)(void*) /* Function used to reclaim memory */
);

namespace {

struct parser_deleter {
  void operator()(void* ptr) { RealMathParseFree(ptr, free); }
};
using unique_parser = std::unique_ptr<void, parser_deleter>;

int lookup_major(real::math::parse::token_type t) {
  switch (t) {
    case real::math::parse::token_type::value:
      return RMTOKEN_VALUE;
    case real::math::parse::token_type::id:
      return RMTOKEN_ID;
    case real::math::parse::token_type::plus:
      return RMTOKEN_PLUS;
    case real::math::parse::token_type::minus:
      return RMTOKEN_MINUS;
    case real::math::parse::token_type::mul:
      return RMTOKEN_MUL;
    case real::math::parse::token_type::div:
      return RMTOKEN_DIV;
    case real::math::parse::token_type::perc:
      return RMTOKEN_PERC;
    case real::math::parse::token_type::lparen:
      return RMTOKEN_LPAREN;
    case real::math::parse::token_type::rparen:
      return RMTOKEN_RPAREN;
    case real::math::parse::token_type::exp:
      return RMTOKEN_EXP;
    case real::math::parse::token_type::eql:
      return RMTOKEN_EQ;
    case real::math::parse::token_type::dot:
      return RMTOKEN_DOT;
    case real::math::parse::token_type::comma:
      return RMTOKEN_COMMA;
    default:
      throw std::logic_error{"unhandled major token."};
  }
}

}  // namespace

namespace real::math::parse {

parse_error::parse_error() : std::runtime_error("unknown parsing failure.") {}
parse_error::parse_error(const char* msg) : std::runtime_error{msg} {}

std::string get_string(std::istream& stream, std::streampos beg) {
  stream.seekg(-1, std::ios::cur);
  auto curr = stream.tellg();
  assert(curr >= beg);
  size_t len = curr - beg + 1;
  std::string result(len, '\0');
  stream.seekg(beg);
  stream.read(result.data(), static_cast<std::streamsize>(len));
  curr += 1;
  stream.seekg(curr);
  return result;
}

void parse(std::istream& stream) {
  tokenizer next{stream};
  unique_parser parser{RealMathParseAlloc(malloc)};
  parse_state context;
  for (;;) {
    auto token = next();
    if (!token.has_value()) {
      if (token.error().code == token_error_code::eof) {
        break;
      }
      // TODO: handle errors
      throw;
    }
    RealMathParse(parser.get(), lookup_major(token->type), &*token, &context);
    if (context.error.has_value()) {
      throw *context.error;
    }
  }
  RealMathParse(parser.get(), 0, nullptr, &context);
  if (!context.done) {
    throw parse_error{"the input is not accepted."};
  }
}

}  // namespace real::math::parse